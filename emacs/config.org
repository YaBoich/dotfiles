#+title: Emacs Configuration

* Core

** GC Tinkering & Faster Startup

Turn off GC during startup and whenever the minibuffer is open.
We also use a different value than the default GC threshold.

#+BEGIN_SRC emacs-lisp
  (defun turn-off-gc ()
    "Turn off garbage collection."
    (setq gc-cons-threshold most-positive-fixnum)
    (setq gc-cons-percentage 0.6))

  (defun turn-on-gc ()
    "Turn on Garbage Collection."
    (setq gc-cons-threshold 30 * 1000 * 1000) 
    (setq gc-cons-percentage 0.2))

  (turn-off-gc)
  (add-hook 'after-init-hook #'turn-on-gc)

  (add-hook 'minibuffer-setup-hook #'turn-off-gc)
  (add-hook 'minibuffer-exit-hook #'turn-on-gc)

  (setq garbage-collection-messages t) ;; change to nil if you're annoyed.

  (add-hook 'emacs-startup-hook
            (lambda () (message "Emacs ready in %s with %d garbage collections."
                                (format (emacs-init-time)) gcs-done)))

#+END_SRC

** File Encoding (UTF-8)

#+begin_src emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
  (set-keyboard-coding-system 'utf-8-unix)

  ;; For Windows, especially. Mainly for python output
  (set-terminal-coding-system 'utf-8-unix)

#+end_src

** Installing Packages
   
#+begin_src emacs-lisp
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  ;; Initializes the package infrastructure
  (package-initialize) 

  (unless package-archive-contents
    (package-refresh-contents))

  ;; Init for non-linux platforms
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  ;; If there are no archived package contents, refresh them
  (when (not package-archive-contents)
    (package-refresh-contents))

  (require 'use-package)

  ;; Adds ":ensure t" to all use-package declarations
  (setq use-package-always-ensure t)

#+end_src

** Change Backup and Auto-Save Directory

This prevents clutter all over your filesystem and centralizes all of the backup and auto-save files in one place.

#+begin_src emacs-lisp
  (unless (file-exists-p "~/.dotfiles/emacs/backups")
    (make-directory "~/.dotfiles/emacs/backups"))
  (setq backup-directory-alist `(("." . "~/.dotfiles/emacs/backups")))

  (unless (file-exists-p "~/.dotfiles/emacs/auto-save-list/")
    (make-directory "~/.dotfiles/emacs/auto-save-list/"))
  (setq auto-save-file-name-transforms `((".*" "~/.dotfiles/emacs/auto-save-list/" t)))

#+end_src

** Change Custom Location

If we don't do this, emacs will automatically write custom data to our init.el

Instead - we redirect this to its own file.

#+begin_src emacs-lisp
(setq custom-file "~/.dotfiles/emacs/custom.el")

;; Check if the file exists; if not, create it
(unless (file-exists-p custom-file)
  (write-region "" nil custom-file))

(load custom-file)

#+end_src

** General (custom keybinding)

This is a core piece of config as all configuration below this may define custom keybinds.

The General package provides a more convenient method for binding keys. Works nicely with evil, too! :D

The SPC key now is the key to invoke our general boich/leader-keys keybind "namespace".

#+begin_src emacs-lisp
  (use-package general)

  (general-create-definer boich/leader-keys
    :keymaps '(normal insert visual emacs)
    :prefix "SPC"
    :global-prefix "C-SPC")

#+end_src

** Make fullscreen after init

#+begin_src emacs-lisp
  (add-hook 'after-init-hook 'toggle-frame-fullscreen)

#+end_src


* Interface

** Basic Settings

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (setq visible-bell t)   ; Rather than the constant pinging noise

  (scroll-bar-mode -1)    ; Disable the visible scrollbar
  (tool-bar-mode -1)      ; Disable the toolbar
  (tooltip-mode -1)       ; Disable tooltips
  (set-fringe-mode 30)    ; Gives some breathing room
  ;; (menu-bar-mode -1)   ; Disable the menu bar

  (setq scroll-margin 10) ; Maintain lines below and above cursor
  (pixel-scroll-mode 0)   
  (setq scroll-step 1)   

#+end_src

** Theme

#+begin_src emacs-lisp
  (use-package doom-themes
    :init (load-theme 'doom-gruvbox t))
  ;; I also quite like: doom-one

#+end_src

** Doom Modeline

#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1)
    :custom
    (doom-modeline-height 15 "set the height")
    (column-number-mode 1)
    ;; Whether display the battery status. It respects `display-battery-mode'.
    (doom-modeline-battery t)
    ;; Whether display the time. It respects `display-time-mode'.
    (doom-modeline-time t)
    (doom-modeline-icon 1)
    :config
    (display-battery-mode 1)
    (display-time-mode 1))

#+end_src

** Font

Can have custom font settings per face type.

#+begin_src emacs-lisp
  (defcustom boich/default-font-size 150
    "Default font size."
    :type 'number)

  (defun boich/set-font-face (face font size &optional weight)
    "Utility function to set font face if font exists."
    (when (find-font (font-spec :name font))
      (set-face-attribute face nil :font font :height size :weight (or weight 'normal))
      t))

  (unless (boich/set-font-face 'default "Fira Code" boich/default-font-size)
    (message "Warning: Font 'Fira Code' is not available."))

  (unless (boich/set-font-face 'fixed-pitch "Fira Code" boich/default-font-size)
    (message "Warning: Font 'Fira Code' is not available for fixed-pitch."))

  (unless (boich/set-font-face 'variable-pitch "Cantarell" boich/default-font-size 'regular)
    (message "Warning: Font 'Cantarell' is not available for variable-pitch."))

#+end_src

** Rainbow Delimiters

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

** Icons

*** all-the-icons

#+begin_src emacs-lisp
  (use-package all-the-icons)

  (defun boich/all-the-icons-ensure-fonts-installed ()
    "Ensure that all-the-icons fonts are installed."
    (unless (find-font (font-spec :name "all-the-icons"))
      (all-the-icons-install-fonts t)))

  (boich/all-the-icons-ensure-fonts-installed)

#+end_src

*** nerd-icons

#+begin_src emacs-lisp
  (use-package nerd-icons)

  (defun boich/nerd-icons-ensure-installed ()
    "Ensure that nerd-icons fonts are installed."
    (unless (find-font (font-spec :name "Symbols Nerd Font Mono"))
      (nerd-icons-install-fonts t)))

  (boich/nerd-icons-ensure-installed)

#+end_src

** Line Numbers

#+begin_src emacs-lisp
  (global-display-line-numbers-mode)
  (setq display-line-numbers-type 'relative)

#+end_src

*** Modes to Exclude

#+begin_src emacs-lisp
(dolist (mode '(;; org-mode-hook
                term-mode-hook
                shell-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode -1))))
#+end_src


* Controls, Keybinds & Helpers [f]

** Evil Mode (Vim keybinds)
   
*** Base Setup
    
Few things happening here:

- Binding ESC and BACKSPACE functionality to C-g and C-h so that you can always keep hands on the home row (Only in INSERT MODE).
- Use visual line motions even outside of visual-line-mode buffers.
- Jump to next line visually even if it's the truncated line of the same line.
- Hit 'q' to close any help panel mini-buffer that pops up.
- Allows use of TAB in org mode

#+begin_src emacs-lisp
  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)

    :config
    (evil-mode 1)

    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))

#+end_src

*** Evil Collection
    
This package makes evil play nicely with most modes

Some benefits:
- Can hit enter on things in dired to navigate to them.

#+begin_src emacs-lisp

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

#+end_src

*** Undo Functionality

Evil needs you to tell it how to handle undo.

#+begin_src emacs-lisp

  (use-package undo-tree
    :init
    (global-undo-tree-mode 1)
    :config
    (when (featurep 'evil) 
      (evil-set-undo-system 'undo-tree)))

  ;; For undo-tree
  (unless (file-exists-p "~/.dotfiles/emacs/undo-tree/")
    (make-directory "~/.dotfiles/emacs/undo-tree/"))
  (setq undo-tree-history-directory-alist `(("." . "~/.dotfiles/emacs/undo-tree/")))

#+end_src

*** Keybinds

| Keybind     | Action                            |
|-------------+-----------------------------------|
| C-w H/J/K/L | Move window                       |
| C-g         | ESC in INSERT mode                |
| C-h         | Backspace in INSERT mode          |
| z-a         | Toggle fold that cursor is within |
|-------------+-----------------------------------|

** Ivy Completion

*** Ivy Core 

https://github.com/abo-abo/swiper

This installs 3 packages:

- Ivy: a generic completion mechanism.
- Counsel: a collection of Ivy-enhanced versions of common commands.
- Swiper: an Ivy-enhanced alternative to Isearch

Can now hit M-o in M-x menu for extra options regarding the thing you’re hovering over.

#+begin_src emacs-lisp
  (use-package swiper)

  (use-package counsel)

  (use-package ivy
    :init (ivy-mode)
    :bind(("C-f" . swiper)
          ("M-x" . counsel-M-x)
          ("C-x b" . counsel-ibuffer)
          ("C-x C-f" . counsel-find-file)
          :map minibuffer-local-map
          ("C-r" . 'counsel-minibuffer-history)
          :map ivy-minibuffer-map
          ("TAB" . ivy-alt-done)
          ("C-l" . ivy-alt-done)
          ("C-j" . ivy-next-line)
          ("C-k" . ivy-previous-line)
          :map ivy-switch-buffer-map
          ("C-k" . ivy-previous-line)
          ("C-l" . ivy-done)
          ("C-d" . ivy-switch-buffer-kill)
          :map ivy-reverse-i-search-map
          ("C-k" . ivy-previous-line)
          ("C-d" . ivy-reverse-i-search-kill))
    :demand
    :config
    (ivy-mode 1)
    (setq ivy-initial-inputs-alist nil)) ; Don't start searches with ^

#+end_src

*** Ivy Rich

Provides text alongside M-x commands that describes what they do.

#+begin_src emacs-lisp
(use-package ivy-rich
  :init
  (ivy-rich-mode 1))

#+end_src

*** Hotkeys

#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)

#+end_src

** Which Key

A package that shows you options for a hotkey. For example if you hit C-c and wait for the defined delay time below, a window will appear showing you your options. Some options in the window:
- C-h j -> next page
- C-h q -> close

#+begin_src emacs-lisp
  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :demand
    :custom
    (which-key-idle-delay 0.1)
    :config
    (which-key-mode 1))

#+end_src

** Helpful

Helpful is a package that enriches the documentation provided when using ‘C-h f/v/k/b’.

Can also just M-x “^describe…” and see what else you can describe.

#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))

#+end_src

** Hydra

Hydra is a package that lets you create transient keybind sessions for an action. So below I’ve got one where I can change my text scale and then finalize it.

- Import the package.
- Define the transient keybind set.
- Add them to my general leader keybind (later on in keybinds).

#+begin_src emacs-lisp
  (use-package hydra)

  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("q" nil "finished" :exit t))

  (defhydra hydra-adjust-window (:timeout 4)
    "grow or shrink the current window"
    ("h" evil-window-decrease-width "decrease width")
    ("j" evil-window-decrease-height "decrease height")
    ("k" evil-window-increase-height "increase width")
    ("l" evil-window-increase-width "increase width")
    ("q" nil "finished" :exit t))

#+end_src

** Avy Navigation (Ace Jump Mode)

NOTE: There is already an isearch (forward and back) bound to s-f and s-F. Try that, too!

(Used to be something called [[https://github.com/winterTTr/ace-jump-mode/][Ace Jump Mode]])

This is an amazing way to navigate vertically and horizontally.

See [[https://github.com/abo-abo/avy][the github]]

There's also a reddit post [[https://www.reddit.com/r/emacs/comments/3e1ozx/acejumpmode_is_dead_long_live_avy/][here]] where people have put a few wonderful
nuggets of information. I learned there that:

evil-motion-state-map is a thing you can bind stuff to that will only apply during a vim motion. So below 'p' will only be hotkeyed to that if you're in a motion like 'dw'. So for example. You could do 'dpn (then hit the key ascociated with "nuggets", above)' and it would delete everything from where you are up until the word "nuggets". 


#+begin_src emacs-lisp
  (use-package avy)
  (global-set-key (kbd "C-;") 'avy-goto-word-1)

  (define-key evil-motion-state-map (kbd "p") #'avy-goto-word-1)
  (define-key evil-motion-state-map (kbd "P") #'avy-goto-line)

#+end_src

So now if I hit C-: then type 1 letter, I can get to any word on the
screen by hitting the letters it shows next to them. That's pretty dam
amazing. Enjoy that shit and feel free to change the hotkey.

** Recent files

#+begin_src emacs-lisp
  (recentf-mode 1)

#+end_src

** Projectile

#+begin_src emacs-lisp
  (use-package projectile)

#+end_src

** Window Management Help (evil-window)

Here's a nice workflow tip. When you're using magit or something and a horizontal buffer split happens, you can use 'C-w _' to make the buffer you're on take up MOST of the screen. Here's a table of things for that kind've situation:

NOTE: I've also created a transient keybind session thing using hyrda that lets you adjust your window width/height.

|--------------------+---------+-------------------------------------------------|
| Situation          | Keybind | Description                                     |
|--------------------+---------+-------------------------------------------------|
| Horizontal split   | C-w _   | Make current window take up most of the screen  |
| Vertical split     | C-w     | Make current window take up most of the screen  |
| Any split          | C-w o   | Delete all windows except this one              |
| Any split          | C-w =   | Balance windows                                 |
|--------------------+---------+-------------------------------------------------|
| Manage window Size | SPC t w | Begins a hydra session to manage current window |
| -> (In session)    | h       | Shrink Width (vim style)                        |
| -> (In session)    | j       | Shrink Height (vim style)                       |
| -> (In session)    | k       | Increase Height (vim style)                     |
| -> (In session)    | l       | Increase Width (vim style)                      |
|--------------------+---------+-------------------------------------------------|

** Keybinds

|---------+------------------------|
| Keybind | Action                 |
|---------+------------------------|
| SPC-f b | counsel-switch-buffer  |
| SPC-f s | counsel-find-file      |
| SPC-f r | recentf-open-files     |
| SPC-f R | counsel-recentf        |
| SPC-f g | projectile-grep        |
| SPC-f f | projectile--find-file  |
| SPC-f d | projectile-find-dir    |
| SPC-f p | projectile-command-map |
|---------+------------------------|

#+begin_src emacs-lisp
  (boich/leader-keys
    "f" '(:ignore t :which-key "files & buffers")
    "fb" '(counsel-switch-buffer :which-key "switch buffer")
    "fs" '(counsel-find-file :which-key "switch path")
    "fr" '(recentf-open-files :which-key "recent files (menu)")
    "fR" '(counsel-recentf :which-key "recent files (search)")
    "fg" '(projectile-grep :which-key "grep files")
    "ff" '(projectile--find-file :which-key "find file")
    "fd" '(projectile-find-dir :which-key "find dir")
    "fh" '(dired-jump :which-key "dired here")
    "fp" '(projectile-command-map :which-key "projectile command map"))

  ;; Allow fullscreening in OSX
  (global-set-key (kbd "M-s-f") 'toggle-frame-fullscreen)

  (general-define-key
   "C-s" 'counsel-grep-or-swiper
   "C-c r" 'reload-config)

  (defun reload-config ()
    "Reloads ~/.emacs.d/init.el"
    (interactive)
    (load-file "~/.emacs.d/init.el"))

  (boich/leader-keys
    "t" '(:ignore t :which-key "toggles")
    "tt" '(counsel-load-theme :which-key "choose theme")
    "ts" '(hydra-text-scale/body :which-key "scale-text")
    "tw" '(hydra-adjust-window/body :which-key "adjust-window"))

#+end_src


* Org Mode [o]

This config assumes that a separate *~/Org/* directory exists containing its own literate config in a *README.org*. This way the following can all be set or contained locally within the org config relative to itself:
- =org-directory=
- =org-roam-directory=
- =org-archive-location=
- =org-capture-templates=
- Actual capture template files.
- Actual org files.
- Actual org-roam files.

... and whatever else you might have related to your actual collection of org files and configuration.

This config simply installs and sets up org-mode, org-babel, org-roam, and their keybinds. The init.el shipped with this configuration looks for and loads this literate config file if it exists (_~/Org/README.org_).

** Core

*** Setup Hook

#+begin_src emacs-lisp
  (defun boich/org-mode-setup()
    "Setup hook run on org-mode buffers"
    (org-indent-mode 1)
    (variable-pitch-mode -1)
    (auto-fill-mode 0)
    (visual-line-mode 1)
    (setq evil-auto-indent nil))

#+end_src

*** Install Package

Emacs comes with org mode, but we include org in our package-archive to get latest version. Can look at ‘org-version’ variable to see what we have.

#+begin_src emacs-lisp
  (use-package org
    :hook (org-mode . boich/org-mode-setup)
    :config
    (setq org-ellipsis "...")
    (setq org-hide-emphasis.markers t) ; Bold text won't show markers around it.
    (setq org-log-done t)
    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)          ; When I complete a task, log the time. ('note)
    (setq org-log-into-drawer t)       ; Fold logs into drawer under tasks
    (setq org-return-follows-link t))  ; Follow links with ENTER

#+end_src

*** Bullets & Faces

Makes org's bullets look much nicer.

First few * chars use same color as background color. So they are still there, but less noisy.

#+begin_src emacs-lisp
  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode))

  (with-eval-after-load 'org-faces
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1)
                    (org-level-5 . 1)
                    (org-level-6 . 1)
                    (org-level-7 . 1)
                    (org-level-8 . 1)))
      (set-face-attribute (car face) nil :font "Fira Code" :weight 'regular :height (cdr face))))
  ;; Can pick a nice variable width font like 'Cantarell' for headings.

  ;; Replace list hyphens with dots, uses a regex got the dot from here https://fsymbols.com/signs/bullet-point/
  (font-lock-add-keywords
   'org-mode
   '(("^ *\\([-]\\) "
      (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

#+end_src

*** Visual Fill

#+begin_src emacs-lisp
  (defun boich/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :defer t
    :hook (org-mode . boich/org-mode-visual-fill))

#+end_src

*** Open links with ENTER in Evil

#+begin_src emacs-lisp
  (with-eval-after-load 'evil
    (evil-define-key 'normal org-mode-map (kbd "RET") 'org-open-at-point))

#+end_src

** Org Babel

*** Load Languages

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (shell . t)))

  (setq org-confirm-babel-evaluate nil)

#+end_src

*** Templates

This lets you just write "<el TAB" and it'll auto create a babel block for emacs-lisp.

#+begin_src emacs-lisp
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))

#+end_src

** Org Roam

#+begin_src emacs-lisp
  (use-package org-roam
    :hook
    (after-init . org-roam-mode) 
    :config
    (org-roam-db-autosync-enable))

#+end_src

** Keybinds

[C-c]:   The general major-mode keybind namespace.
[SPC-o]: My org keybind namespace.

|----------+----------------------------------------------|
| Keybind  | Action                                       |
|----------+----------------------------------------------|
| za       | Vim toggle collapse/expand header            |
| C-c C-l  | Insert Link                                  |
| C-c C-o  | open-at-point (Can use enter)                |
| SPC-o a  | org-agenda                                   |
| SPC-o f  | org-refile                                   |
| SPC-o r  | Roam menu                                    |
| SPC-o p  | org-capture                                  |
| SPC-o ci | org-clock-in                                 |
| SPC-o co | org-clock-out                                |
| SPC-o cr | org-clock-report                             |
| C-c C-c  | Re-evaluate clock table after adjusting tags |
|----------+----------------------------------------------|
| ======== | Specifically for Org-Babel                   |
|----------+----------------------------------------------|
| C-c '    | org-edit-source-code within a block          |
| C-x C-s  | Save source edit buffer (for above)          |
| C-x C-c  | Close source edit buffer (for above)         |
|----------+----------------------------------------------|

#+begin_src emacs-lisp
  (boich/leader-keys
    "o" '(:ignore t :which-key "org")
    "oa" '(org-agenda :which-key "agenda")
    "of" '(org-refile :which-key "refile")
    "oc" '(:ignore t :which-key "clock")
    "op" '(org-capture :which-key "capture")
    "oci" '(org-clock-in :which-key "clock in")
    "oco" '(org-clock-out :which-key "clock out")
    "ocr" '(org-clock-report :which-key "clock report")
    "or" '(:ignore t :which-key "roam")
    "orf" '(org-roam-node-find :which-key "find file")
    "orb" '(org-roam-buffer-toggle :which-key "buffer")
    "ori" '(org-roam-node-insert :which-key "insert")
    "orc" '(org-roam-capture :which-key "capture")
    "ord" '(org-roam-dailies-capture-today :which-key "daily")
    )

#+end_src


* Magit [g]

** Install & Configure

#+begin_src emacs-lisp
  (use-package magit
  :custom
  ;; Commit message fill column (72 is conventional width)
  (git-commit-fill-column 72)
  ;; Auto revert mode (auto-refresh the status buffer, but not other magit buffers)
  (magit-auto-revert-mode t)
  ;; Show refined hunks during diff (shows word-granularity changes)
  (magit-diff-refine-hunk t)

  :config
  ;; Use full screen for magit-status, restoring previous window config on quit
  (setq magit-status-buffer-switch-function 'switch-to-buffer)

  (defun magit-fullscreen-advice (orig-fun &rest args)
    (window-configuration-to-register :magit-fullscreen)
    (apply orig-fun args)
    (delete-other-windows))

  (defun magit-restore-screen-advice (orig-fun &rest args)
    (window-configuration-to-register :quit-magit)
    (apply orig-fun args)
    (jump-to-register :magit-fullscreen))

  (advice-add 'magit-status :around #'magit-fullscreen-advice)
  (advice-add 'magit-quit-window :around #'magit-restore-screen-advice)

  ;; Integrate with `which-key` if you have it to show magit-dispatch-popup key hints
  (when (boundp 'which-key-mode)
    (add-hook 'magit-mode-hook 'which-key-mode)))

#+end_src

** Help

Below are some of the most common/useful keybinds for the main features of Magit.

*** magit-status (SPC g s)

This is the primary Magit interface, where you can see the status of your repository.

|---------+-----------------------------------------------------------------------|
| Keybind | Function                                                              |
|---------+-----------------------------------------------------------------------|
| s       | Stage the file under point or the region.                             |
| u       | Unstage the file under point or the region.                           |
| c c     | Commit the staged changes (finalize with C-c C-c in the mini-buffer). |
| F F     | Pull from the remote repository.                                      |
| P P     | Push to the remote repository.                                        |
| d d     | Diff unstaged changes.                                                |
| D D     | Diff committed changes.                                               |
| l l     | View the log (commit history).                                        |
| b b     | Switch branches.                                                      |
| x       | Discard changes in the file under point or the region.                |
| TAB     | Toggle visibility of diff for a file or commit details.               |
|---------+-----------------------------------------------------------------------|

*** magit-dispatch (SPC g d)

This brings up a pop-up window with a list of Magit commands you can execute, providing a quick access to various Magit commands.

|---------+----------------|
| Keybind | Function       |
|---------+----------------|
| l       | Log pop-up.    |
| d       | Diff pop-up.   |
| f       | Fetch pop-up.  |
| P       | Push pop-up.   |
| F       | Pull pop-up.   |
| b       | Branch pop-up. |
| m       | Merge pop-up.  |
|---------+----------------|

*** magit-file-dispatch (SPC g f)

This is a pop-up specifically for actions related to files.

|---------+---------------------------|
| Keybind | Function                  |
|---------+---------------------------|
| s       | Stage the current file.   |
| u       | Unstage the current file. |
| d       | Diff the current file.    |
|---------+---------------------------|

** Keybinds

|---------+-----------------------------|
| Keybind | Description                 |
|---------+-----------------------------|
| SPC-g s | Magit Status                |
| SPC-g d | Dispatch general menu       |
| SPC-g f | Dispatch menu for this file |
| SPC-g b | Magit Blame                 |
| SPC-g S | Magit Stash                 |
| SPC-g B | Branch & Checkout           |
| SPC-g m | Merge                       |
| SPC-g r | Rebase                      |
| SPC-g p | Pull                        |
|---------+-----------------------------|

#+begin_src emacs-lisp
  (boich/leader-keys
    "g" '(:ignore t :which-key "git (magit)")
    "gs" '(magit-status :which-key "status")
    "gd" '(magit-dispatch :which-key "dispatch")
    "gf" '(magit-file-dispatch :which-key "dispatch (file)")
    "gb" '(magit-blame :which-key "blame")
    "gS" '(magit-stash :which-key "stash")
    "gB" '(magit-branch-and-checkout :which-key "branch and checkout")
    "gm" '(magit-merge :which-key "merge")
    "gr" '(magit-rebase :which-key "rebase")
    "gp" '(magit-pull :which-key "pull"))

#+end_src


* Development

** Rust Support

Trying to get an IDE-like rust experience. Syntax checks, auto-completion, etc.

TODO: Right now it's far from perfect. Needs some work. I'm not getting the level of anything that I would expect:
- No completions or information.
- Some syntax/compiler checking but not much.

#+begin_src emacs-lisp

  ;; Syntax highlighting and other basic rust features
  (use-package rust-mode
    :hook
    (rust-mode . (lambda ()
                   (setq indent-tabs-mode nil)
                   (setq rust-format-on-save t)))
    :config
    (setq rust-format-on-save t))
  ;;
  ;; Language Server Protocol support. The LSP provides features like auto-completion, goto-definition, and many other IDE-like features.
  (use-package lsp-mode
    :hook (rust-mode . lsp)
    :custom
    (lsp-rust-server 'rust-analyzer)
    (lsp-rust-analyzer-cargo-watch-command "clippy")
    (lsp-rust-analyzer-server-display-inlay-hints t)
    :config
    (add-hook 'lsp-mode-hook 'lsp-lens-mode))

  ;; Provides a frontend for autocompletion.
  (use-package company
    :hook (after-init . global-company-mode))

  ;; Syntax checking for your code.
  (use-package flycheck
    :hook (after-init . global-flycheck-mode))

  ;; Make it use "rust" - can manually select these by running 'M-x flycheck-verify-setup'
  (add-hook 'rust-mode-hook
            (lambda ()
              (flycheck-mode)
              (setq flycheck-checker 'rust)))

  ;; Editing support for Cargo.toml files.
  (use-package toml-mode :ensure t)

  ;; Adds emacs bindings for various cargo commands
  (use-package cargo
    :hook (rust-mode . cargo-minor-mode))

  ;; direnv allows directory-specific environment configurations, which can be useful if you're working on multiple Rust projects with different toolchains or environment variables.
  ;; Now, you can use .envrc files in your Rust project directories to specify directory-specific configurations.
  (use-package direnv
    :config
    (direnv-mode))

  ;; Snippet support
  (use-package yasnippet
    :config
    (yas-global-mode 1))

#+end_src

** Local VCS Change Indication

This shows me diffs within programming buffers.

I could also add diffs in dired and other modes, see below.

There are multiple modes you can use listed [[https://github.com/dgutov/diff-hl#about][here]]:
- =diff-hl-dired-mode= provides similar functionality in Dired.
- =diff-hl-margin-mode= changes the highlighting function to use the margin instead of the fringe.
- =diff-hl-amend-mode= sets the reference revision to the one before recent one. Also, you could use diff-hl-set-reference-rev to set it to any revision, see its docstring for details.
- =diff-hl-flydiff-mode= implements highlighting changes on the fly.
- =diff-hl-show-hunk-mouse-mode= makes fringe and margin react to mouse clicks to show the corresponding hunk. That's the alternative to using diff-hl-show-hunk and friends.

#+begin_src emacs-lisp
      (use-package diff-hl
        :config
        (diff-hl-margin-mode 1))

      ;; Enable `diff-hl' support by default in programming buffers
      (add-hook 'prog-mode-hook #'diff-hl-mode)

#+end_src

** Misc

*** Whitespace Mode

If you copy and paste things you can sometimes get a *zero-width whitespace*. These are the most annoying things that exist. Whitespace mode helps you identify stuff like this.

You can enable this by running =(whitespace-mode)=.

#+begin_src emacs-lisp
  (require 'whitespace)

  ;; Add the zero-width space to the whitespace-style
  (setq whitespace-style '(face tabs spaces trailing lines space-before-tab
                                newline indentation empty space-after-tab
                                space-mark tab-mark newline-mark))

  ;; Add the zero-width space to the display mappings
  (setq whitespace-display-mappings
        '(
          ;; (space-mark ?\u200B [?·]) ; display zero-width space as middle dot
          (space-mark ?\u200B [?◊]) ; display zero-width space as diamond
          (newline-mark ?\n [?\u00B6 ?\n]) ; end-of-line
          (tab-mark ?\t [?\u00BB ?\t] [?\\ ?\t]) ; tab
          ))

#+end_src

*** Automatically pair parentheses

#+begin_src emacs-lispy
(electric-pair-mode t)

#+end_src

*** Window resizing and saving place/history.

#+begin_src emacs-lisp
  (setq window-resize-pixelwise t)
  (setq frame-resize-pixelwise t)
  (save-place-mode t)
  (savehist-mode t)

#+end_src
