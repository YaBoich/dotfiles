#+title: Emacs Configuration

* Core

** GC Tinkering & Faster Startup

Turn off GC during startup and whenever the minibuffer is open.
We also use a different value than the default GC threshold.

#+BEGIN_SRC emacs-lisp
  (defun turn-off-gc ()
    "Turn off garbage collection."
    (setq gc-cons-threshold most-positive-fixnum)
    (setq gc-cons-percentage 0.6))

  (defun turn-on-gc ()
    "Turn on Garbage Collection."
    (setq gc-cons-threshold 30 * 1000 * 1000) 
    (setq gc-cons-percentage 0.2))

  (turn-off-gc)
  (add-hook 'after-init-hook #'turn-on-gc)

  (add-hook 'minibuffer-setup-hook #'turn-off-gc)
  (add-hook 'minibuffer-exit-hook #'turn-on-gc)

  (setq garbage-collection-messages t) ;; change to nil if you're annoyed.

  (add-hook 'emacs-startup-hook
            (lambda () (message "Emacs ready in %s with %d garbage collections."
                                (format (emacs-init-time)) gcs-done)))

#+END_SRC

** File Encoding (UTF-8)

#+begin_src emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
  (set-keyboard-coding-system 'utf-8-unix)

  ;; For Windows, especially. Mainly for python output
  (set-terminal-coding-system 'utf-8-unix)

#+end_src

** Installing Packages
   
#+begin_src emacs-lisp
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))

  ;; Initializes the package infrastructure
  (package-initialize) 

  (unless package-archive-contents
    (package-refresh-contents))

  ;; Init for non-linux platforms
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  ;; If there are no archived package contents, refresh them
  (when (not package-archive-contents)
    (package-refresh-contents))

  (require 'use-package)

  ;; Adds ":ensure t" to all use-package declarations
  (setq use-package-always-ensure t)

#+end_src

** General (custom keybinding)

This is a core piece of config as all configuration below this may define custom keybinds.

The General package provides a more convenient method for binding keys. Works nicely with evil, too! :D

The SPC key now is the key to invoke our general boich/leader-keys keybind "namespace".

#+begin_src emacs-lisp
  (use-package general)

  (general-create-definer boich/leader-keys
    :keymaps '(normal insert visual emacs)
    :prefix "SPC"
    :global-prefix "C-SPC")

#+end_src


* Interface

** Basic Settings

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
  (setq visible-bell t)   ; Rather than the constant pinging noise

  (scroll-bar-mode -1)    ; Disable the visible scrollbar
  (tool-bar-mode -1)      ; Disable the toolbar
  (tooltip-mode -1)       ; Disable tooltips
  (set-fringe-mode 30)    ; Gives some breathing room
  ;; (menu-bar-mode -1)   ; Disable the menu bar

  (setq scroll-margin 10) ; Maintain lines below and above cursor
  (pixel-scroll-mode 0)   
  (setq scroll-step 1)   

#+end_src

** Theme

#+begin_src emacs-lisp
  (use-package doom-themes
    :init (load-theme 'doom-gruvbox t))
  ;; I also quite like: doom-one

#+end_src

** Doom Modeline

#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1)
    :custom
    (doom-modeline-height 15 "set the height")
    (column-number-mode 1)
    ;; Whether display the battery status. It respects `display-battery-mode'.
    (doom-modeline-battery t)
    ;; Whether display the time. It respects `display-time-mode'.
    (doom-modeline-time t)
    :config
    (display-battery-mode 1)
    (display-time-mode 1))

#+end_src

** Font

Can have custom font settings per face type.

#+begin_src emacs-lisp
  (defcustom boich/default-font-size 150
    "Default font size."
    :type 'number)

  (defun boich/set-font-face (face font size &optional weight)
    "Utility function to set font face if font exists."
    (when (find-font (font-spec :name font))
      (set-face-attribute face nil :font font :height size :weight (or weight 'normal))
      t))

  (unless (boich/set-font-face 'default "Fira Code" boich/default-font-size)
    (message "Warning: Font 'Fira Code' is not available."))

  (unless (boich/set-font-face 'fixed-pitch "Fira Code" boich/default-font-size)
    (message "Warning: Font 'Fira Code' is not available for fixed-pitch."))

  (unless (boich/set-font-face 'variable-pitch "Cantarell" boich/default-font-size 'regular)
    (message "Warning: Font 'Cantarell' is not available for variable-pitch."))

#+end_src

** Rainbow Delimiters

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

** Icons

#+begin_src emacs-lisp
  (use-package all-the-icons)

  (defun boich/all-the-icons-ensure-fonts-installed ()
    "Ensure that all-the-icons fonts are installed."
    (unless (find-font (font-spec :name "all-the-icons"))
      (all-the-icons-install-fonts t)))

  (boich/all-the-icons-ensure-fonts-installed)

#+end_src

** Line Numbers

#+begin_src emacs-lisp
  (global-display-line-numbers-mode)
  (setq display-line-numbers-type 'relative)

#+end_src

*** Modes to Exclude

#+begin_src emacs-lisp
(dolist (mode '(;; org-mode-hook
                term-mode-hook
                shell-mode-hook
                eshell-mode-hook))
  (add-hook mode (lambda () (display-line-numbers-mode -1))))
#+end_src


* Controls, Keybinds & Helpers [f]

** Evil Mode (Vim keybinds)
   
*** Base Setup
    
Few things happening here:

- Binding ESC and BACKSPACE functionality to C-g and C-h so that you can always keep hands on the home row (Only in INSERT MODE).
- Use visual line motions even outside of visual-line-mode buffers.
- Jump to next line visually even if it's the truncated line of the same line.
- Hit 'q' to close any help panel mini-buffer that pops up.
- Allows use of TAB in org mode

#+begin_src emacs-lisp
  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)

    :config
    (evil-mode 1)

    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))

#+end_src

*** Evil Collection
    
This package makes evil play nicely with most modes

Some benefits:
- Can hit enter on things in dired to navigate to them.

#+begin_src emacs-lisp

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

#+end_src

*** Undo Functionality

Evil needs you to tell it how to handle undo.

#+begin_src emacs-lisp

  (use-package undo-tree
    :init
    (global-undo-tree-mode 1)
    :config
    (when (featurep 'evil) 
      (evil-set-undo-system 'undo-tree)))

#+end_src

*** Keybinds

| Keybind     | Action                            |
|-------------+-----------------------------------|
| C-w H/J/K/L | Move window                       |
| C-g         | ESC in INSERT mode                |
| C-h         | Backspace in INSERT mode          |
| z-a         | Toggle fold that cursor is within |
|-------------+-----------------------------------|

** Ivy Completion

*** Ivy Core 

https://github.com/abo-abo/swiper

This installs 3 packages:

- Ivy: a generic completion mechanism.
- Counsel: a collection of Ivy-enhanced versions of common commands.
- Swiper: an Ivy-enhanced alternative to Isearch

Can now hit M-o in M-x menu for extra options regarding the thing you’re hovering over.

#+begin_src emacs-lisp
  (use-package swiper)

  (use-package counsel)

  (use-package ivy
    :init (ivy-mode)
    :bind(("C-f" . swiper)
          ("M-x" . counsel-M-x)
          ("C-x b" . counsel-ibuffer)
          ("C-x C-f" . counsel-find-file)
          :map minibuffer-local-map
          ("C-r" . 'counsel-minibuffer-history)
          :map ivy-minibuffer-map
          ("TAB" . ivy-alt-done)
          ("C-l" . ivy-alt-done)
          ("C-j" . ivy-next-line)
          ("C-k" . ivy-previous-line)
          :map ivy-switch-buffer-map
          ("C-k" . ivy-previous-line)
          ("C-l" . ivy-done)
          ("C-d" . ivy-switch-buffer-kill)
          :map ivy-reverse-i-search-map
          ("C-k" . ivy-previous-line)
          ("C-d" . ivy-reverse-i-search-kill))
    :demand
    :config
    (ivy-mode 1)
    (setq ivy-initial-inputs-alist nil)) ; Don't start searches with ^

#+end_src

*** Ivy Rich

Provides text alongside M-x commands that describes what they do.

#+begin_src emacs-lisp
(use-package ivy-rich
  :init
  (ivy-rich-mode 1))

#+end_src

*** Hotkeys

#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)

#+end_src

** Which Key

A package that shows you options for a hotkey. For example if you hit C-c and wait for the defined delay time below, a window will appear showing you your options. Some options in the window:
- C-h j -> next page
- C-h q -> close

#+begin_src emacs-lisp
  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :demand
    :custom
    (which-key-idle-delay 0.1)
    :config
    (which-key-mode 1))

#+end_src

** Helpful

Helpful is a package that enriches the documentation provided when using ‘C-h f/v/k/b’.

Can also just M-x “^describe…” and see what else you can describe.

#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))

#+end_src

** Hydra

Hydra is a package that lets you create transient keybind sessions for an action. So below I’ve got one where I can change my text scale and then finalize it.

- Import the package.
- Define the transient keybind set.
- Add them to my general leader keybind (later on in keybinds).

#+begin_src emacs-lisp
  (use-package hydra)

  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("q" nil "finished" :exit t))

  (defhydra hydra-adjust-window (:timeout 4)
    "grow or shrink the current window"
    ("h" evil-window-decrease-width "decrease width")
    ("j" evil-window-decrease-height "decrease height")
    ("k" evil-window-increase-height "increase width")
    ("l" evil-window-increase-width "increase width")
    ("q" nil "finished" :exit t))

#+end_src

** Avy Navigation (Ace Jump Mode)

NOTE: There is already an isearch (forward and back) bound to s-f and s-F. Try that, too!

(Used to be something called [[https://github.com/winterTTr/ace-jump-mode/][Ace Jump Mode]])

This is an amazing way to navigate vertically and horizontally.

See [[https://github.com/abo-abo/avy][the github]]

There's also a reddit post [[https://www.reddit.com/r/emacs/comments/3e1ozx/acejumpmode_is_dead_long_live_avy/][here]] where people have put a few wonderful
nuggets of information. I learned there that:

evil-motion-state-map is a thing you can bind stuff to that will only apply during a vim motion. So below 'p' will only be hotkeyed to that if you're in a motion like 'dw'. So for example. You could do 'dpn (then hit the key ascociated with "nuggets", above)' and it would delete everything from where you are up until the word "nuggets". 


#+begin_src emacs-lisp
  (use-package avy)
  (global-set-key (kbd "C-:") 'avy-goto-word-1)

  (define-key evil-motion-state-map (kbd "p") #'avy-goto-word-1)
  (define-key evil-motion-state-map (kbd "P") #'avy-goto-line)

#+end_src

So now if I hit C-: then type 1 letter, I can get to any word on the
screen by hitting the letters it shows next to them. That's pretty dam
amazing. Enjoy that shit and feel free to change the hotkey.

** Recent files

#+begin_src emacs-lisp
  (recentf-mode 1)

#+end_src

** Projectile

#+begin_src emacs-lisp
  (use-package projectile)

#+end_src

** Window Management Help (evil-window)

Here's a nice workflow tip. When you're using magit or something and a horizontal buffer split happens, you can use 'C-w _' to make the buffer you're on take up MOST of the screen. Here's a table of things for that kind've situation:

NOTE: I've also created a transient keybind session thing using hyrda that lets you adjust your window width/height.

|--------------------+---------+-------------------------------------------------|
| Situation          | Keybind | Description                                     |
|--------------------+---------+-------------------------------------------------|
| Horizontal split   | C-w _   | Make current window take up most of the screen  |
| Vertical split     | C-w     | Make current window take up most of the screen  |
| Any split          | C-w o   | Delete all windows except this one              |
| Any split          | C-w =   | Balance windows                                 |
|--------------------+---------+-------------------------------------------------|
| Manage window Size | SPC t w | Begins a hydra session to manage current window |
| -> (In session)    | h       | Shrink Width (vim style)                        |
| -> (In session)    | j       | Shrink Height (vim style)                       |
| -> (In session)    | k       | Increase Height (vim style)                     |
| -> (In session)    | l       | Increase Width (vim style)                      |
|--------------------+---------+-------------------------------------------------|

** Keybinds

|---------+------------------------|
| Keybind | Action                 |
|---------+------------------------|
| SPC-f b | counsel-switch-buffer  |
| SPC-f s | counsel-find-file      |
| SPC-f r | recentf-open-files     |
| SPC-f R | counsel-recentf        |
| SPC-f g | projectile-grep        |
| SPC-f f | projectile--find-file  |
| SPC-f d | projectile-find-dir    |
| SPC-f p | projectile-command-map |
|---------+------------------------|

#+begin_src emacs-lisp
  (boich/leader-keys
    "f" '(:ignore t :which-key "files & buffers")
    "fb" '(counsel-switch-buffer :which-key "switch buffer")
    "fs" '(counsel-find-file :which-key "switch path")
    "fr" '(recentf-open-files :which-key "recent files (menu)")
    "fR" '(counsel-recentf :which-key "recent files (search)")
    "fg" '(projectile-grep :which-key "grep files")
    "ff" '(projectile--find-file :which-key "find file")
    "fd" '(projectile-find-dir :which-key "find dir")
    "fp" '(projectile-command-map :which-key "projectile command map"))

  ;; Allow fullscreening in OSX
  (global-set-key (kbd "M-s-f") 'toggle-frame-fullscreen)

  (general-define-key
   "C-s" 'counsel-grep-or-swiper
   "C-c r" 'reload-config)

  (defun reload-config ()
    "Reloads ~/.emacs.d/init.el"
    (interactive)
    (load-file "~/.emacs.d/init.el"))

  (boich/leader-keys
    "t" '(:ignore t :which-key "toggles")
    "tt" '(counsel-load-theme :which-key "choose theme")
    "ts" '(hydra-text-scale/body :which-key "scale-text")
    "tw" '(hydra-adjust-window/body :which-key "adjust-window"))

#+end_src


* Org Mode [o]

Emacs comes with org mode, but we include org in our package-archive to get latest version. Can look at ‘org-version’ variable to see what we have.

** Core

*** Setup Hook

#+begin_src emacs-lisp
  (defun boich/org-mode-setup()
    "Setup hook run on org-mode buffers"
    (org-indent-mode 1)
    (variable-pitch-mode -1)
    (auto-fill-mode 0)
    (visual-line-mode 1)
    (setq evil-auto-indent nil))

#+end_src

*** Install Package

#+begin_src emacs-lisp
  (use-package org
    :hook (org-mode . boich/org-mode-setup)
    :config
    (setq org-ellipsis "...")
    (setq org-hide-emphasis.markers t) ; Bold text won't show markers around it.
    (setq org-log-done t)
    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)          ; When I complete a task, log the time. ('note)
    (setq org-log-into-drawer t)       ; Fold logs into drawer under tasks
    (setq org-return-follows-link t))  ; Follow links with ENTER

#+end_src

*** Bullets & Faces

Makes org's bullets look much nicer.

First few * chars use same color as background color. So they are still there, but less noisy.

#+begin_src emacs-lisp
  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode))

  (with-eval-after-load 'org-faces
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1)
                    (org-level-5 . 1)
                    (org-level-6 . 1)
                    (org-level-7 . 1)
                    (org-level-8 . 1)))
      (set-face-attribute (car face) nil :font "Fira Code" :weight 'regular :height (cdr face))))
  ;; Can pick a nice variable width font like 'Cantarell' for headings.

  ;; Replace list hyphens with dots, uses a regex got the dot from here https://fsymbols.com/signs/bullet-point/
  (font-lock-add-keywords
   'org-mode
   '(("^ *\\([-]\\) "
      (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

#+end_src

*** Visual Fill

#+begin_src emacs-lisp
  (defun boich/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :defer t
    :hook (org-mode . boich/org-mode-visual-fill))

#+end_src

*** Open links with ENTER in Evil

#+begin_src emacs-lisp
  (with-eval-after-load 'evil
    (evil-define-key 'normal org-mode-map (kbd "RET") 'org-open-at-point))

#+end_src

** Agenda

*** Todo States

Defining custom todo states.

List format:
- Incomplete/active states | complete/inactive states.
- The letter in parens is a is a hotkey when in state switching selector.
- The '!' makes org track state changes in the logbook.
- More info [[https://stackoverflow.com/questions/12262220/add-created-date-property-to-todos-in-org-mode][link]].

#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t!)" "NEXT(n)" "HUSTLING(i!)" "|" "DONE(d!)")
          (sequence "BACKLOG(b!)" "READY(r)" "ACTIVE(a!)" "REVIEW(v!)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELLED(k@!)")))

#+end_src

To choose which of these to use, you'd use a #+TODO directive at the top of a file, like so:
- #+TODO: Todo Next InProgress | Done
- #+TODO: Backlog Ready Active Review Wait | Done Cancelled

The first sequence is the default.

*** Define Agenda Files

Dynamically add all org files to org-agenda-files.

#+begin_src emacs-lisp
  (require 'find-lisp)
  (require 'cl-lib)

  (defun boich/all-org-files ()
    "Return a list of all .org files in the ~/Org directory."
    (directory-files-recursively "~/Org/" "\\.org$"))

  (defun boich/active-org-files ()
    "Return a list of all .org files in the ~/Org directory except those in ~/Org/Archive/."
    (cl-remove-if
     (lambda (file)
       (string-prefix-p (expand-file-name "~/Org/Archive/") file))
     (boich/all-org-files)))

  (defun boich/update-org-agenda-files ()
    "Update the org-agenda-files variable."
    (setq org-agenda-files (boich/active-org-files)))

  (boich/update-org-agenda-files)

  (add-hook 'org-agenda-mode-hook 'boich/update-org-agenda-files)

#+end_src

*** Define Refile Targets

Using org-refile, move an org header to another file.

#+begin_src emacs-lisp
  (setq org-refile-targets `((,(boich/all-org-files) :maxlevel . 2)))

  ;; Save Org Buffers after refiling
  (advice-add 'org-refile :after 'org-save-all-org-buffers)

#+end_src

*** Define Agenda Views

See David's [[https://youtu.be/PNE-mgkZ6HM?t=1604][here]]
And his actual configuration [[https://github.com/daviwil/emacs-from-scratch/blob/c55d0f5e309f7ed8ffa3c00bc35c75937a5184e4/init.el][here]]

#+begin_src emacs-lisp

  (setq org-agenda-custom-commands
        '(("d" "Dashboard"
           ((agenda "" ((org-deadline-warning-days 7)))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Tasks")))
            (tags-todo "agenda/ACTIVE"
                       ((org-agenda-overriding-header "Active Projects")))))

          ("n" "Next Tasks"
           ((todo "NEXT"
                  ((org-agenda-overriding-header "Next Tasks")))))

          ("W" "Work Tasks" tags-todo "+work-email")

          ;; Low-effort next actions
          ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
           ((org-agenda-overriding-header "Low Effort Tasks")
            (org-agenda-max-todos 20)
            (org-agenda-files org-agenda-files)))

          ("w" "Workflow Status"
           ((todo "REVIEW"
                  ((org-agenda-overriding-header "In Review")
                   (org-agenda-files org-agenda-files)))
            (todo "BACKLOG"
                  ((org-agenda-overriding-header "Project Backlog")
                   (org-agenda-todo-list-sublevels nil)
                   (org-agenda-files org-agenda-files)))
            (todo "READY"
                  ((org-agenda-overriding-header "Ready for Work")
                   (org-agenda-files org-agenda-files)))
            (todo "ACTIVE"
                  ((org-agenda-overriding-header "Active Projects")
                   (org-agenda-files org-agenda-files)))
            (todo "DONE"
                  ((org-agenda-overriding-header "Completed Projects")
                   (org-agenda-files org-agenda-files)))
            (todo "CANCELLED"
                  ((org-agenda-overriding-header "Cancelled Projects")
                   (org-agenda-files org-agenda-files)))))))

  (setq org-tag-alist
        '((:startgroup)
          ;; Put mututally exclusive tags here
          (:endgroup)
          ("@errand" . ?E)
          ("@home" . ?H)
          ("@work" . ?W)
          ("agenda" . ?a)
          ("planning" . ?p)
          ("publish" . ?P)
          ("batch" . ?b)
          ("note" . ?n)
          ("idea" . ?i)))

#+end_src

** Capture Templates

Org/Capture structure:
|-------------------+--------------------------------------------------------------|
| Path              | Contents                                                     |
|-------------------+--------------------------------------------------------------|
| ~/Org/capture.org | Personal Tasks and Ideas                                     |
| ~/Org/dairy.org   | Work Dairy for schedule, must-do tasks, and calendar entries |
| ~/Org/journal.org | Personal Journal & Gratitude Journalling                     |
| ~/Org/metrics.org | Metrics to keep track of.                                    |
| ~/Org/Templates/  | Directory for Capture templates                              |
| ~/Org/Refile/     | Directory for common refiles (like archive)                  |
|-------------------+--------------------------------------------------------------|

Org capture templates define preset structures and destinations for quickly adding new content to Org files.

Good for quickly jotting down ideas without taking you out've your main workflow.

The task template here for example does the following:
- Creates a TODO note under the "Inbox" top-level heading in the "~/Org/capture.org" file.
- Automatically includes a link back to wherever you invoked the capture template from.
- Automatically includes the date.

So now combined with org-agenda, that capture would now show up in your org-agenda list, and would have a link to whatever it was you were doing when you captured it. This could be your code, and org-file, and email using mu4e, whatever...

Journals work with datetree. When you capture a journal entry it'll go into a journal file and it'll be automatically placed under year/month/date headings. Isn't that really cool? :D

The weight metric adds entries to a table.

#+begin_src emacs-lisp

  ;; TODO works but not used.
  (defun boich/read-file-as-string (filepath)
    "Return the contents of FILEPATH as a string."
    (with-temp-buffer
      (insert-file-contents filepath)
      (buffer-string)))

  (setq org-capture-templates
        `(("t" "Tasks / Projects")
          ("tt" "Task" entry (file+olp "~/Org/capture.org" "Inbox")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("ti" "Idea" entry (file+olp "~/Org/capture.org" "Ideas") 
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

          ("d" "Dairy (Work)")
          ("dt" "Task" entry (file+olp "~/Org/dairy.org" "Inbox")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("dg" "General" entry (file+olp "~/Org/dairy.org" "Inbox")
           "* TODO %?\n  %U\n  %a\n" :empty-lines 1)

          ("j" "Journal Entries")
          ;; TODO this one doesn't work because of that template. Can check out system crafters video to see what you're supposed to do?
          ("jj" "Journal" entry
           (file+olp+datetree "~/Org/journal.org")
           "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n" ,(boich/read-file-as-string "~/Org/Templates/daily.org")
           :clock-in :clock-resume :empty-lines 1)
          ("jm" "Meeting" entry
           (file+olp+datetree "~/Org/journal.org")
           "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
           :clock-in :clock-resume :empty-lines 1)

          ("w" "Workflows")
          ("we" "Checking Email" entry (file+olp+datetree "~/Org/journal.org")
           "* Checking Email :email:\n\n%?"
           :clock-in :clock-resume :empty-lines 1)

          ("m" "Metrics Capture")
          ("mw" "Weight" table-line (file+headline "~/Org/metrics.org" "Weight") "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t))) 

#+end_src

** Org Babel

*** Load Languages

#+begin_src emacs-lisp
  (org-babel-do-load-languages
    'org-babel-load-languages
      '((emacs-lisp . t)
      (python . t)
      (shell . t)))
    
  (setq org-confirm-babel-evaluate nil)
#+end_src

*** Templates

This lets you just write "<el TAB" and it'll auto create a babel block.

#+begin_src emacs-lisp
(require 'org-tempo)

(add-to-list 'org-structure-template-alist '("sh" . "src shell"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
#+end_src

** Keybinds

[C-c]:   The general major-mode keybind namespace.
[SPC-o]: My org keybind namespace.

|---------+--------------------------------------|
| Keybind | Action                               |
|---------+--------------------------------------|
| za      | Vim toggle collapse/expand header    |
| C-c C-l | Insert Link                          |
| C-c C-o | open-at-point (Can use enter)        |
| SPC-o a | org-agenda                           |
| SPC-o r | org-refile                           |
| SPC-o c | org-capture                          |
|---------+--------------------------------------|
| ------- | Specifically for Org-Babel           |
|---------+--------------------------------------|
| C-c '   | org-edit-source-code within a block  |
| C-x C-s | Save source edit buffer (for above)  |
| C-x C-c | Close source edit buffer (for above) |
|---------+--------------------------------------|

#+begin_src emacs-lisp
    (boich/leader-keys
      "o" '(:ignore t :which-key "org")
      "oa" '(org-agenda :which-key "agenda")
      "or" '(org-refile :which-key "refile")
      "oc" '(org-capture :which-key "capture"))

#+end_src


* Magit [g]

** Install & Configure

#+begin_src emacs-lisp
  (use-package magit
  :custom
  ;; Commit message fill column (72 is conventional width)
  (git-commit-fill-column 72)
  ;; Auto revert mode (auto-refresh the status buffer, but not other magit buffers)
  (magit-auto-revert-mode t)
  ;; Show refined hunks during diff (shows word-granularity changes)
  (magit-diff-refine-hunk t)

  :config
  ;; Use full screen for magit-status, restoring previous window config on quit
  (setq magit-status-buffer-switch-function 'switch-to-buffer)

  (defun magit-fullscreen-advice (orig-fun &rest args)
    (window-configuration-to-register :magit-fullscreen)
    (apply orig-fun args)
    (delete-other-windows))

  (defun magit-restore-screen-advice (orig-fun &rest args)
    (window-configuration-to-register :quit-magit)
    (apply orig-fun args)
    (jump-to-register :magit-fullscreen))

  (advice-add 'magit-status :around #'magit-fullscreen-advice)
  (advice-add 'magit-quit-window :around #'magit-restore-screen-advice)

  ;; Integrate with `which-key` if you have it to show magit-dispatch-popup key hints
  (when (boundp 'which-key-mode)
    (add-hook 'magit-mode-hook 'which-key-mode)))

#+end_src

** Help

Below are some of the most common/useful keybinds for the main features of Magit.

*** magit-status (SPC g s)

This is the primary Magit interface, where you can see the status of your repository.

|---------+-----------------------------------------------------------------------|
| Keybind | Function                                                              |
|---------+-----------------------------------------------------------------------|
| s       | Stage the file under point or the region.                             |
| u       | Unstage the file under point or the region.                           |
| c c     | Commit the staged changes (finalize with C-c C-c in the mini-buffer). |
| F F     | Pull from the remote repository.                                      |
| P P     | Push to the remote repository.                                        |
| d d     | Diff unstaged changes.                                                |
| D D     | Diff committed changes.                                               |
| l l     | View the log (commit history).                                        |
| b b     | Switch branches.                                                      |
| x       | Discard changes in the file under point or the region.                |
| TAB     | Toggle visibility of diff for a file or commit details.               |
|---------+-----------------------------------------------------------------------|

*** magit-dispatch (SPC g d)

This brings up a pop-up window with a list of Magit commands you can execute, providing a quick access to various Magit commands.

|---------+----------------|
| Keybind | Function       |
|---------+----------------|
| l       | Log pop-up.    |
| d       | Diff pop-up.   |
| f       | Fetch pop-up.  |
| P       | Push pop-up.   |
| F       | Pull pop-up.   |
| b       | Branch pop-up. |
| m       | Merge pop-up.  |
|---------+----------------|

*** magit-file-dispatch (SPC g f)

This is a pop-up specifically for actions related to files.

|---------+---------------------------|
| Keybind | Function                  |
|---------+---------------------------|
| s       | Stage the current file.   |
| u       | Unstage the current file. |
| d       | Diff the current file.    |
|---------+---------------------------|

** Keybinds

|---------+-----------------------------|
| Keybind | Description                 |
|---------+-----------------------------|
| SPC-g s | Magit Status                |
| SPC-g d | Dispatch general menu       |
| SPC-g f | Dispatch menu for this file |
| SPC-g b | Magit Blame                 |
| SPC-g S | Magit Stash                 |
| SPC-g B | Branch & Checkout           |
| SPC-g m | Merge                       |
| SPC-g r | Rebase                      |
| SPC-g p | Pull                        |
|---------+-----------------------------|

#+begin_src emacs-lisp
  (boich/leader-keys
    "g" '(:ignore t :which-key "git (magit)")
    "gs" '(magit-status :which-key "status")
    "gd" '(magit-dispatch :which-key "dispatch")
    "gf" '(magit-file-dispatch :which-key "dispatch (file)")
    "gb" '(magit-blame :which-key "blame")
    "gS" '(magit-stash :which-key "stash")
    "gB" '(magit-branch-and-checkout :which-key "branch and checkout")
    "gm" '(magit-merge :which-key "merge")
    "gr" '(magit-rebase :which-key "rebase")
    "gp" '(magit-pull :which-key "pull"))

#+end_src


* Development

** Company Mode

To get auto-complete and suggestions in config.org for emacs-lisp source blocks, you can use company-mode, which is a popular auto-completion framework for Emacs. Setting up company-mode for org-mode source blocks requires enabling it in org-mode and ensuring that the backend for emacs-lisp is active when editing source blocks.

#+begin_src emacs-lisp
  (use-package company
    :hook ((after-init . global-company-mode)
           (org-mode . company-mode)
           (org-src-mode . my-org-mode-company-setup))
    :config
    (setq company-idle-delay 0.5                ; delay before popup
          company-minimum-prefix-length 2       ; number of chars to trigger completion
          company-tooltip-align-annotations t)

    ;; Conditionally prepend additional backends for elisp
    (unless (member '(company-capf company-dabbrev-code) company-backends)
      (setq company-backends
            (cons '(company-capf company-dabbrev-code) company-backends))))

  ;; Configure emacs-lisp backend for org-mode source blocks
  (defun my-org-mode-company-setup ()
    (make-local-variable 'company-backends)
    (add-to-list 'company-backends 'company-elisp))

  ;; Babel emacs-lisp Setup
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)))

  (add-hook 'emacs-lisp-mode-hook 'company-mode)
  (add-hook 'org-mode-hook 'company-mode)
  (add-hook 'org-src-mode-hook 'company-mode)

  (global-set-key (kbd "C-<tab>") 'company-complete) ; TODO consider keybinding or move to right place

#+end_src

*** Help

- company-quickhelp
- Go to somewhere you'd expect completions and try 'M-x company-diag'
- Note keybinds, C-<tab> being company completion.


